# The proxy layer

## Introduction

This folder contains all of the files that are a part of so called proxy layer. The purpose of these files is to provide and easy interface to peripherials. Instead of going into details when using our board, one can just grab a function here and use them to easily implement desired logic.

Layer schematic:
1. Logic layer (Top)
2. Proxy layer (Middle)
3. Driver layer (Bottom)

## How to use the proxy layer

If the functionality that you want to use is  supported, just include the header file in the `main.cpp`. The `CMakeLists.txt` makes sure that the files are compiled and automatically linkes them if its needed.

Currently supported peripherials:
- microSD card

Soon to be supported:
- PWM
- BMP280
- UART header
## How to contribute

This section explains how to create a proxy layer module.

You should start with generating code with Cube IDE and test that it works. This guide focuses on how to migrate a code from such project to use with our toolchain.
There are several steps that you need to do:
1. Copy needed HAL library files
2. Edit `stm32_hal_conf.h`
3. Copy library files if needed
4. Edit `CMakeLists.txt`
5. Copy init functions for peripherials
6. Copy init functions for GPIOs
7. Add proxy layer (optional)

### Copying HAL library files

All of the HAL library files that you need to compile Cube IDE project can be found in `Drivers/STM32F4xx_HAL_Driver` directory. Copy them into `3rdparty/STM32F4xx_HAL_Driver` directory. I suggest you copy every file, even if some of them already is in our project - you don't want to miss any of those files.

### Edit `stm32_hal_conf.h`

Make sure that the proper modules are enabled. To enable the module simply uncomment the right `#define` directive. Compare the file generated by cube for reference.

## Add library files to the project

Create a new directory in `3rdparty/` with two subdirectories: `Inc` and `Src`.
Place your header files in `Inc` and source files in `Src` folder.

### Edit `CMakeLists.txt`

First, create a new library, and add all of the source files

```
add_library(LIBRARY_NAME
        3rdparty/LIBRARY_NAME/Src/file1.c
        3rdparty/LIBRARY_NAME/Src/file2.c
        3rdparty/LIBRARY_NAME/Src/file3.c
        )
```
Then, supply cmake with the directory with all of the includes needed to compile your source code:
```
target_include_directories(LIBRARY_NAME PUBLIC
        3rdparty/CMSIS/Include
        3rdparty/CMSIS/Device/ST/STM32F4xx/Include)
```
Now, link the library with the executable
```
target_link_libraries(${ELF_FILE} STARTUP CMSIS)
```
At the end, add the newly created `3rdparty/LIBRARY_NAME/Inc` directory to include directory for the executable. This way you can use functions defined there.
```
target_include_directories(${ELF_FILE} PUBLIC
        3rdparty/LIBRARY_NAME/Inc
        )
``

If some parts are unclear, take a look how the FATFS library is defined.
### Copy init functions for peripherials
You have to copy functions that init interfaces like `i2c` or `spi` into the `bsp.c` and add their prototypes into `bsp.h`.
### Init GPIOs
Make sure that gpios that you are using are initialized. Check if gpio initalization from you project is contained within `bsp.c` function that does that.